# 卫星信号可见性计算软件 - 架构决策和基本原理

## 文档信息
- **文件名称**：CLINE-decisions.md
- **创建日期**：2025-01-09
- **最后更新**：2025-01-09
- **文件用途**：记录架构决策和基本原理

## 技术栈选择决策

### 决策1：后端技术栈选择Node.js + Express

#### 决策内容
选择Node.js作为后端运行环境，Express作为Web框架。

#### 决策背景
- 项目需要100ms的实时更新频率
- 需要处理WebSocket实时通信
- 需要高效的I/O处理能力
- 团队对JavaScript技术栈熟悉

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| Node.js + Express | 轻量级、高并发、异步I/O、WebSocket支持好 | 单线程、CPU密集型任务性能一般 | 实时性要求高、I/O密集型、团队熟悉 |
| Python + Django | 生态丰富、科学计算库多、开发效率高 | 性能相对较低、实时性支持一般 | 计算密集但实时性要求不高 |
| Java + Spring Boot | 性能好、稳定性高、生态完善 | 重量级、开发效率相对较低 | 性能要求高但开发周期长 |
| Go + Gin | 性能极高、并发性好、轻量级 | 生态相对年轻、学习成本高 | 极高性能要求但团队不熟悉 |

#### 决策结果
选择Node.js + Express，主要基于以下考虑：
1. **实时性要求**：Node.js的异步I/O模型适合100ms更新频率
2. **WebSocket支持**：Express + Socket.io提供良好的实时通信支持
3. **开发效率**：JavaScript全栈开发，团队熟悉度高
4. **生态系统**：npm生态丰富，有大量现成的库可以使用

#### 决策影响
- 开发效率提升，预计缩短开发周期20%
- 需要注意CPU密集型计算的性能优化
- 需要合理使用集群模式来充分利用多核CPU

### 决策2：前端技术栈选择React

#### 决策内容
选择React作为前端框架，配合Three.js进行3D可视化。

#### 决策背景
- 需要3D可视化显示飞机和卫星位置
- 需要实时更新界面（100ms更新频率）
- 需要良好的组件化和状态管理
- 团队对React技术栈有经验

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| React + Three.js | 组件化好、生态丰富、性能优化好 | 学习曲线较陡、需要额外状态管理 | 3D可视化需求、组件化要求高 |
| Vue.js + Three.js | 学习曲线平缓、中文文档好 | 3D生态相对较少 | 团队React经验更丰富 |
| Angular + Three.js | 框架完整、企业级支持 | 学习曲线陡、性能相对较重 | 项目规模适中，不需要过度工程化 |
| 原生JavaScript + Three.js | 性能最好、无框架开销 | 开发效率低、维护成本高 | 开发周期和可维护性更重要 |

#### 决策结果
选择React + Three.js，主要基于以下考虑：
1. **3D可视化需求**：Three.js是Web端最成熟的3D库
2. **组件化要求**：React的组件化模式适合复杂的UI界面
3. **实时更新**：React的状态管理和虚拟DOM适合100ms更新频率
4. **团队经验**：团队对React有丰富的开发经验

#### 决策影响
- 前端开发效率提升，组件复用率预计达到60%
- 需要注意Three.js的性能优化，避免频繁重渲染
- 需要合理使用React.memo和useMemo来优化性能

## 架构设计决策

### 决策3：采用微服务架构vs单体架构

#### 决策内容
选择单体架构，采用模块化设计。

#### 决策背景
- 项目规模适中，预计12周完成
- 团队规模小，需要快速开发和部署
- 实时性要求高，微服务间通信可能成为瓶颈
- 需要100ms的端到端响应时间

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| 单体架构 | 开发效率高、部署简单、性能好、通信成本低 | 扩展性受限、技术栈固定 | 项目规模适中、实时性要求高 |
| 微服务架构 | 扩展性好、技术栈灵活、团队自治 | 开发效率低、部署复杂、通信开销大 | 项目规模小，不需要微服务的复杂性 |
| 混合架构 | 平衡扩展性和开发效率 | 架构复杂、需要更多设计 | 项目周期短，不需要过度设计 |

#### 决策结果
选择单体架构，主要基于以下考虑：
1. **项目规模**：12周的开发周期，适合单体架构
2. **实时性要求**：100ms响应时间，微服务间通信会增加延迟
3. **团队规模**：小团队，单体架构更易于管理和协作
4. **部署简单性**：单体架构部署和运维成本更低

#### 决策影响
- 开发效率提升，预计缩短开发周期30%
- 需要良好的模块化设计来避免代码耦合
- 未来扩展到微服务架构时需要重构成本

### 决策4：实时通信架构选择

#### 决策内容
选择WebSocket作为实时通信方式，配合RESTful API。

#### 决策背景
- 需要100ms的实时更新频率
- 需要双向通信（服务器推送和客户端请求）
- 需要良好的浏览器兼容性
- 需要处理大量并发连接

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| WebSocket | 双向通信、实时性好、性能高 | 连接管理复杂、需要心跳机制 | 100ms实时更新、双向通信需求 |
| Server-Sent Events | 简单、自动重连、单向通信 | 只支持服务器到客户端 | 需要双向通信 |
| Long Polling | 兼容性好、实现简单 | 性能差、服务器负载高 | 实时性要求高，性能更重要 |
| WebRTC | P2P通信、延迟极低 | 复杂、浏览器支持有限 | 不需要P2P通信 |

#### 决策结果
选择WebSocket，主要基于以下考虑：
1. **实时性要求**：WebSocket提供最低的延迟，适合100ms更新
2. **双向通信**：需要服务器推送实时数据，也需要客户端请求
3. **性能考虑**：WebSocket连接建立后通信开销小
4. **技术成熟度**：WebSocket技术成熟，有稳定的库支持

#### 决策影响
- 实时性能提升，延迟可以控制在20ms以内
- 需要实现连接管理、心跳机制、断线重连等功能
- 需要考虑WebSocket连接的负载均衡和扩展性

## 算法选择决策

### 决策5：卫星位置计算算法选择

#### 决策内容
选择基于开普勒轨道根数的卫星位置计算算法。

#### 决策背景
- 需要根据RINEX星历数据计算卫星位置
- 需要支持北斗B3I和GPS L1 C/A频点
- 需要高精度的位置计算（<10m精度）
- 需要满足100ms计算时间要求

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| 开普勒轨道根数法 | 精度高、计算效率好、标准方法 | 需要考虑摄动修正 | RINEX数据提供轨道根数，精度要求高 |
| 数值积分法 | 精度最高、考虑所有摄动 | 计算量大、实时性差 | 计算时间要求100ms，不适合 |
| 简化解析法 | 计算速度快、实现简单 | 精度较低、不适合高精度要求 | 精度要求高，不能牺牲精度 |
| 插值法 | 实现简单、计算快 | 依赖预计算数据、灵活性差 | 需要实时计算任意时间点 |

#### 决策结果
选择开普勒轨道根数法，主要基于以下考虑：
1. **数据匹配**：RINEX星历数据直接提供开普勒轨道根数
2. **精度要求**：可以满足<10m的精度要求
3. **性能要求**：计算时间可以控制在10ms以内
4. **标准方法**：这是卫星导航领域的标准计算方法

#### 决策影响
- 计算精度满足要求，预计位置误差<5m
- 计算性能满足要求，单次计算<5ms
- 需要实现摄动修正算法来提高精度
- 需要考虑不同卫星系统的参数差异

### 决策6：坐标转换算法选择

#### 决策内容
选择基于旋转矩阵的坐标转换算法。

#### 决策背景
- 需要在多个坐标系之间转换：
  - WGS84大地坐标系（LLA）
  - 地心地固坐标系（ECEF）
  - 机体坐标系（Body）
- 需要高精度的转换（<1m精度）
- 需要满足100ms计算时间要求

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| 旋转矩阵法 | 精度高、数值稳定、计算效率好 | 需要多次矩阵乘法 | 精度要求高，计算效率好 |
| 四元数法 | 计算效率高、避免万向节锁 | 精度相对较低、实现复杂 | 精度要求更重要 |
| 欧拉角法 | 直观易懂、实现简单 | 万向节锁问题、精度较低 | 精度要求高，不适合 |
| 球面三角法 | 计算简单、适合小范围 | 精度低、不适合全球范围 | 需要全球范围高精度转换 |

#### 决策结果
选择旋转矩阵法，主要基于以下考虑：
1. **精度要求**：旋转矩阵法可以满足<1m的转换精度
2. **数值稳定性**：旋转矩阵法数值稳定，不会出现万向节锁
3. **计算效率**：矩阵运算可以优化，满足100ms计算时间
4. **标准方法**：这是大地测量和导航领域的标准方法

#### 决策影响
- 转换精度满足要求，预计转换误差<0.5m
- 计算性能满足要求，单次转换<1ms
- 需要实现多种坐标系之间的转换矩阵
- 需要考虑地球椭球模型的影响

### 决策7：遮挡计算算法选择

#### 决策内容
选择基于简化几何模型的遮挡计算算法。

#### 决策背景
- 需要计算飞机对卫星信号的遮挡
- 需要考虑飞机姿态对遮挡的影响
- 需要满足100ms计算时间要求
- 需要识别具体的遮挡部件（机身、机翼、尾翼）

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| 简化几何模型 | 计算快、实现简单、易于理解 | 精度相对较低、简化了复杂形状 | 实时性要求高，100ms计算时间 |
| 精确几何模型 | 精度高、考虑复杂形状 | 计算量大、实现复杂 | 计算时间要求严格，不适合 |
| 射线追踪法 | 精度最高、可以处理复杂形状 | 计算量极大、实时性差 | 实时性要求高，不适合 |
| 快速近似算法 | 计算最快、内存占用少 | 精度最低、误差较大 | 精度有一定要求，不能牺牲太多精度 |

#### 决策结果
选择简化几何模型，主要基于以下考虑：
1. **实时性要求**：简化几何模型计算时间<10ms，满足100ms更新要求
2. **实现复杂度**：简化几何模型实现相对简单，开发周期短
3. **可理解性**：简化几何模型易于理解和调试
4. **精度平衡**：在实时性和精度之间取得良好平衡

#### 决策影响
- 计算性能满足要求，单次遮挡计算<5ms
- 遮挡精度基本满足要求，可以识别主要遮挡部件
- 需要定义合理的飞机几何模型参数
- 需要考虑不同飞机形状的模型适配

## 信号处理算法决策

### 决策8：信号传播模型选择

#### 决策内容
选择自由空间传播损耗模型，不考虑复杂的环境因素。

#### 决策背景
- 需要计算卫星信号的传播损耗
- 需要支持北斗B3I（1268.52MHz）和GPS L1 C/A（1575.42MHz）频点
- 需要满足100ms计算时间要求
- 主要考虑飞机遮挡，不考虑大气、地形等环境因素

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| 自由空间传播模型 | 计算简单、标准方法、精度足够 | 不考虑环境因素 | 主要考虑飞机遮挡，环境因素影响小 |
| Okumura-Hata模型 | 考虑地形、建筑物等环境因素 | 计算复杂、参数多、不适合卫星通信 | 适用于地面移动通信，不适用于卫星 |
| ITU-R P.618模型 | 考虑大气、雨衰等环境因素 | 计算复杂、需要大量环境参数 | 环境因素影响相对较小，不需要过度复杂 |
| 两径模型 | 考虑多径效应 | 计算复杂、参数难以确定 | 多径效应影响相对较小，可以忽略 |

#### 决策结果
选择自由空间传播模型，主要基于以下考虑：
1. **计算效率**：自由空间传播模型计算简单，满足100ms计算时间
2. **适用性**：适用于卫星通信的远距离传播
3. **精度足够**：对于飞机遮挡分析，自由空间模型精度足够
4. **标准方法**：这是卫星通信领域的标准传播模型

#### 决策影响
- 计算性能满足要求，单次计算<1ms
- 传播损耗计算精度满足要求，误差<1dB
- 需要实现不同频点的传播损耗计算
- 需要考虑天线增益的影响

### 决策9：天线增益模型选择

#### 决策内容
选择简化的天线增益方向图模型。

#### 决策背景
- 需要计算天线在不同方向的增益
- 需要支持全向天线和定向天线
- 需要满足100ms计算时间要求
- 主要考虑飞机姿态对天线指向的影响

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| 简化方向图模型 | 计算简单、参数少、易于理解 | 精度相对较低、简化了复杂方向图 | 实时性要求高，计算时间限制 |
| 精确方向图模型 | 精度高、可以模拟复杂方向图 | 计算复杂、需要大量测量数据 | 计算时间要求严格，不适合 |
| 数值积分法 | 精度最高、可以处理任意形状 | 计算量极大、实时性差 | 实时性要求高，不适合 |
| 插值法 | 计算较快、可以使用测量数据 | 需要预计算数据、灵活性差 | 需要实时计算任意方向 |

#### 决策结果
选择简化方向图模型，主要基于以下考虑：
1. **计算效率**：简化方向图模型计算时间<1ms，满足100ms更新要求
2. **参数简单**：只需要最大增益和3dB波束宽度两个参数
3. **易于理解**：简化模型易于理解和调试
4. **精度平衡**：在实时性和精度之间取得良好平衡

#### 决策影响
- 计算性能满足要求，单次计算<0.5ms
- 天线增益计算精度基本满足要求，误差<0.5dB
- 需要定义不同类型天线的增益参数
- 需要考虑飞机姿态对天线指向的影响

## 性能优化决策

### 决策10：缓存策略选择

#### 决策内容
选择内存缓存策略，缓存计算结果以提高性能。

#### 决策背景
- 需要100ms的更新频率
- 卫星位置计算和坐标转换计算量较大
- 相同时间点的计算结果会被多次使用
- 需要平衡内存使用和计算性能

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| 内存缓存 | 访问速度快、实现简单 | 内存占用大、进程重启丢失 | 计算性能要求高，内存充足 |
| 磁盘缓存 | 容量大、持久化 | 访问速度慢、I/O开销大 | 实时性要求高，磁盘I/O太慢 |
| 分布式缓存 | 容量大、可扩展 | 网络开销大、复杂度高 | 单体应用，不需要分布式 |
| 无缓存 | 内存占用小、实现简单 | 计算性能差、重复计算 | 计算性能要求高，不能接受 |

#### 决策结果
选择内存缓存策略，主要基于以下考虑：
1. **性能要求**：内存缓存访问速度最快，可以显著提高计算性能
2. **实现简单**：内存缓存实现简单，开发成本低
3. **数据特性**：计算结果有时间局部性，缓存效果好
4. **资源充足**：现代服务器内存充足，可以承受缓存开销

#### 决策影响
- 计算性能显著提升，缓存命中率预计>80%
- 内存占用增加，预计增加50-100MB
- 需要实现缓存失效策略，确保数据新鲜度
- 需要考虑缓存键的设计，避免冲突

### 决策11：并发处理策略选择

#### 决策内容
选择Node.js的异步非阻塞I/O模型，配合Worker Threads处理CPU密集型任务。

#### 决策背景
- 需要处理大量并发连接（>100）
- 需要同时处理多个飞机的计算请求
- 卫星位置计算等任务CPU密集型
- 需要满足100ms的端到端响应时间

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| 异步非阻塞I/O | 并发性能好、内存占用少 | CPU密集型任务性能差 | I/O密集型任务多，适合异步模型 |
| 多进程模型 | CPU利用率好、隔离性好 | 内存占用大、进程间通信复杂 | 需要处理CPU密集型任务 |
| 多线程模型 | 轻量级、CPU利用率好 | 实现复杂、需要处理线程安全 | 需要平衡I/O和CPU性能 |
| 线程池模型 | 资源利用率好、可控性强 | 实现复杂、需要任务调度 | 需要精细控制资源使用 |

#### 决策结果
选择异步非阻塞I/O + Worker Threads的混合策略，主要基于以下考虑：
1. **I/O性能**：异步非阻塞I/O适合处理大量并发连接和WebSocket通信
2. **CPU性能**：Worker Threads可以处理CPU密集型的卫星位置计算
3. **资源平衡**：混合策略可以平衡I/O和CPU性能
4. **技术成熟**：Node.js的异步模型和Worker Threads都是成熟技术

#### 决策影响
- 并发性能提升，可以支持>100个并发连接
- CPU利用率提升，可以充分利用多核CPU
- 实现复杂度增加，需要处理线程间通信
- 需要合理分配任务到不同的Worker Threads

## 测试策略决策

### 决策12：测试自动化框架选择

#### 决策内容
选择Jest + Mocha + Selenium的测试自动化框架组合。

#### 决策背景
- 需要实现TDD（测试驱动开发）模式
- 需要单元测试、集成测试、端到端测试全覆盖
- 需要自动化测试，支持CI/CD流水线
- 需要生成详细的测试报告和覆盖率报告

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| Jest + Mocha + Selenium | 功能全面、生态丰富、社区活跃 | 学习成本高、配置复杂 | 需要完整的测试解决方案 |
| Jasmine + Protractor | 集成好、Angular生态 | 功能相对有限、社区活跃度低 | 项目不限于Angular，需要更通用的解决方案 |
| Cypress + Mocha | 易用性好、调试方便 | 功能相对有限、浏览器支持有限 | 需要多种浏览器支持 |
| Puppeteer + Jest | 轻量级、性能好 | 功能相对有限、学习成本高 | 需要完整的功能测试 |

#### 决策结果
选择Jest + Mocha + Selenium的组合，主要基于以下考虑：
1. **功能全面**：Jest适合单元测试，Mocha适合集成测试，Selenium适合端到端测试
2. **生态丰富**：三个框架都有丰富的插件和社区支持
3. **CI/CD支持**：都支持CI/CD集成，可以生成详细的测试报告
4. **团队熟悉**：团队对这些框架有使用经验

#### 决策影响
- 测试覆盖率提升，预计达到95%以上的单元测试覆盖率
- 开发效率提升，自动化测试减少手动测试工作量
- 需要配置测试环境，编写测试用例
- 需要维护测试数据和测试环境

### 决策13：TDD实施策略选择

#### 决策内容
选择严格的TDD实施策略，先编写测试用例，再实现功能代码。

#### 决策背景
- 需要确保代码质量和测试覆盖率
- 需要减少调试时间和缺陷修复成本
- 需要提高代码的可维护性和可扩展性
- 需要95%以上的测试覆盖率

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| 严格TDD | 代码质量高、测试覆盖全面、设计更好 | 开发速度慢、需要更多测试代码 | 质量要求高，需要95%测试覆盖率 |
| 松散TDD | 开发速度较快、灵活性高 | 代码质量相对较低、测试覆盖不全面 | 质量要求严格，不能牺牲质量 |
| 测试后置 | 开发速度快、灵活性高 | 代码质量差、测试覆盖不全面 | 质量要求高，不能接受测试后置 |
| 无测试 | 开发速度最快 | 代码质量差、维护成本高 | 质量要求高，必须测试 |

#### 决策结果
选择严格TDD实施策略，主要基于以下考虑：
1. **质量要求**：严格TDD可以确保代码质量和测试覆盖率
2. **设计驱动**：TDD可以驱动更好的代码设计
3. **缺陷预防**：TDD可以在早期发现和预防缺陷
4. **维护成本**：TDD可以降低长期的维护成本

#### 决策影响
- 开发速度可能降低20-30%，但质量显著提升
- 测试代码量增加，预计占总代码量的40-50%
- 需要团队培训TDD理念和技能
- 需要建立测试文化和质量意识

## 部署策略决策

### 决策14：容器化部署策略选择

#### 决策内容
选择Docker容器化部署策略，支持多环境部署。

#### 决策背景
- 需要支持开发、测试、生产多个环境
- 需要简化部署流程，减少环境差异
- 需要支持水平扩展和负载均衡
- 需要支持CI/CD自动化部署

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| Docker容器化 | 环境一致、部署简单、扩展性好 | 需要学习Docker、镜像体积大 | 需要多环境部署，简化部署流程 |
| 传统部署 | 部署简单、无需额外学习 | 环境差异大、部署复杂 | 环境一致性要求高，不适合传统部署 |
| 虚拟机部署 | 隔离性好、安全性高 | 资源占用大、部署复杂 | 资源效率要求高，虚拟机太重 |
| 云原生部署 | 扩展性好、自动化程度高 | 复杂度高、需要云平台知识 | 项目规模适中，不需要过度复杂 |

#### 决策结果
选择Docker容器化部署策略，主要基于以下考虑：
1. **环境一致性**：Docker可以确保开发、测试、生产环境的一致性
2. **部署简化**：Docker可以显著简化部署流程，减少环境问题
3. **扩展性好**：Docker支持水平扩展和负载均衡
4. **CI/CD支持**：Docker与CI/CD工具集成良好，支持自动化部署

#### 决策影响
- 部署效率提升，预计部署时间减少80%
- 环境问题减少，预计环境相关bug减少90%
- 需要编写Dockerfile和docker-compose.yml
- 需要团队学习Docker相关知识

### 决策15：CI/CD平台选择

#### 决策内容
选择GitHub Actions作为CI/CD平台。

#### 决策背景
- 项目托管在GitHub上
- 需要自动化测试、构建、部署流程
- 需要支持多环境部署
- 需要生成详细的构建和测试报告

#### 决策选项对比
| 选项 | 优点 | 缺点 | 选择理由 |
|------|------|------|----------|
| GitHub Actions | 与GitHub集成好、免费额度大、配置简单 | 功能相对有限、社区生态相对较小 | 项目在GitHub，集成需求高 |
| Jenkins | 功能强大、插件丰富、社区活跃 | 配置复杂、需要自己维护 | 项目规模适中，不需要过度复杂 |
| GitLab CI | 与GitLab集成好、功能完善 | 需要GitLab、学习成本高 | 项目在GitHub，不适合GitLab |
| CircleCI | 配置简单、性能好 | 免费额度小、功能相对有限 | 免费额度要求高，不适合 |

#### 决策结果
选择GitHub Actions，主要基于以下考虑：
1. **GitHub集成**：GitHub Actions与GitHub完美集成，使用方便
2. **免费额度**：GitHub Actions提供足够的免费额度，满足项目需求
3. **配置简单**：GitHub Actions配置相对简单，学习成本低
4. **社区支持**：GitHub Actions有活跃的社区支持和丰富的Action库

#### 决策影响
- CI/CD效率提升，预计构建和部署时间减少60%
- 开发体验改善，与GitHub无缝集成
- 需要编写GitHub Actions工作流配置文件
- 需要配置多环境的部署流程

---

## 决策记录维护

### 决策更新流程
1. **新决策提出**：当需要做出新的技术或架构决策时
2. **决策分析**：分析决策背景、选项和影响
3. **决策记录**：将决策结果记录到本文档
4. **决策评审**：定期评审决策的有效性和影响

### 决策变更管理
- **变更申请**：任何决策变更都需要正式的变更申请
- **影响分析**：分析变更对项目的影响
- **变更审批**：由技术负责人审批变更
- **变更记录**：记录变更的原因、时间和影响

### 决策责任分配
- **技术负责人**：负责重大技术决策的最终审批
- **架构师**：负责架构设计决策的分析和记录
- **开发团队**：负责实施决策和反馈决策效果
- **项目经理**：负责决策的进度跟踪和风险管理

---

**文档维护说明**
- 本文档记录项目中的重要架构决策和基本原理
- 新的决策需要及时更新到此文档
- 所有团队成员需要了解这些决策的背景和影响
- 决策变更需要有充分的理由和正式的流程
